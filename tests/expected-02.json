{
  "commit": "61c6e6461f62464e870d921d33d853ac841c7420",
  "gpg": [
    "Signature made Fri Apr 25 00:55:24 2025 CEST",
    "               using RSA key AFE8C5F43057C0093122299F584211AF6AB3EE12",
    "               issuer \"ole.elgesem@northern.tech\"",
    "Good signature from \"Ole Herman Schumacher Elgesem <ole@cfengine.com>\" [ultimate]",
    "                aka \"Ole Herman Schumacher Elgesem <olehelg@ifi.uio.no>\" [ultimate]",
    "                aka \"Ole Herman Schumacher Elgesem <olehelg@student.matnat.uio.no>\" [ultimate]",
    "                aka \"Ole Herman Schumacher Elgesem <oleherman93@gmail.com>\" [ultimate]",
    "                aka \"Ole Herman Schumacher Elgesem <ole.elgesem@northern.tech>\" [ultimate]",
    "                aka \"Ole Herman Schumacher Elgesem <ole.elgesem@cfengine.com>\" [ultimate]",
    "                aka \"Ole Herman Schumacher Elgesem <ole@northern.tech>\" [ultimate]",
    "                aka \"Ole Herman Schumacher Elgesem <olehelg@ulrik.uio.no>\" [ultimate]",
    "                aka \"Ole Herman Schumacher Elgesem <olehelg@uio.no>\" [ultimate]"
  ],
  "tree": "ece6177eb4489042bee34fcafc16a123f57cbc7b",
  "author": {
    "id": "Ole Herman Schumacher Elgesem <ole.elgesem@northern.tech>",
    "name": "Ole Herman Schumacher Elgesem",
    "email": "ole.elgesem@northern.tech",
    "timestamp": "1744918684",
    "timezone": "+0200"
  },
  "committer": {
    "id": "Ole Herman Schumacher Elgesem <ole.elgesem@northern.tech>",
    "name": "Ole Herman Schumacher Elgesem",
    "email": "ole.elgesem@northern.tech",
    "timestamp": "1745535319",
    "timezone": "+0200"
  },
  "gpgsig": "-----BEGIN PGP SIGNATURE-----\n\niQJOBAABCAA4FiEEr+jF9DBXwAkxIimfWEIRr2qz7hIFAmgKwVwaHG9sZS5lbGdl\nc2VtQG5vcnRoZXJuLnRlY2gACgkQWEIRr2qz7hIMABAAqZT9E1seWQ1Vr5RasscE\nsVb7pkQrnlH0aF4dudGxFF8GBNLRCJsUwf7r6mIjcIdKFM2DqPDIg2dor3OC2hOX\nvFZxC87iRyX+8sYIhk7F2HNkVK8tTOwUNYm3STKF+7dYYJx5Au0I52aeaVmOnavU\nYyx+SKNwwDsNVrTYWM2U9RyKo1PobnWwVGPbXGamA74hAg4sSPAOEGSJgfqNNRBd\nFtEGFbt6xB1joL5WFE0ChqNgd/HBt5O//k8L9bJ0k5WwfHLZGJLQofyuI4rzkgce\nHg6+cLFX420XWsfNoVTnTiwt7Ga1uLJP6oNBeC62QcOdnh69Cq8abOrbesiG94P1\nwby88VBShcZbWMaYqtX5pWUmhltKG97QmU2bRCe21LLCtnq/wvdx8HmKu462xAnu\nD5gTNHslab8joEG9CwVtUHFDX/jVNVReJduxTov2tV+QRodiFV2nf9tvHLmB1aXU\nKe6ism4jKY+LGtp0PHr5qrPcnf+49SKF707Eh4plVlY8F2N75RxpivoQZ1CnPSAe\nWavgiMi/mRP0y0WjlRp88C+m5cUjJe+brXQ+8Xx7FC9q1vwR1yN4UWpNcoy82z8w\ncGA1Rbt4rAsY2IiAEsCx7TL6GSBXQ/2/M3dS1tO4C6f+R0XuXs/tY9tNCY3oph2a\nprbPnQ0FD1M1woG7oqCvoDo=\n=TNNi\n-----END PGP SIGNATURE-----",
  "message": "Initial commit, working version\n\nSigned-off-by: Ole Herman Schumacher Elgesem <ole.elgesem@northern.tech>",
  "diff": [
    " README.md             |  53 ++++++++++",
    " git_log_raw_parser.py | 269 ++++++++++++++++++++++++++++++++++++++++++++++++++",
    " internal_parser.py    | 264 +++++++++++++++++++++++++++++++++++++++++++++++++",
    " look_for_pulls.py     |  23 +++++",
    " requirements.txt      |   3 +",
    " 6 files changed, 618 insertions(+)",
    "",
    "diff --git a/.gitignore b/.gitignore",
    "new file mode 100644",
    "index 0000000..4316b8d",
    "--- /dev/null",
    "+++ b/.gitignore",
    "@@ -0,0 +1,6 @@",
    "+/core/",
    "+/masterfiles/",
    "+/out/",
    "+__pycache__/",
    "+/debug/",
    "+/trusted/",
    "diff --git a/README.md b/README.md",
    "new file mode 100644",
    "index 0000000..534755a",
    "--- /dev/null",
    "+++ b/README.md",
    "@@ -0,0 +1,53 @@",
    "+# git-log-raw-parser",
    "+",
    "+A parser for parsing the command:",
    "+",
    "+```",
    "+git log -p --format=raw --show-signature --stat",
    "+```",
    "+",
    "+## Why?",
    "+",
    "+The above command provides a lot of useful information about git commits, which we can analyze, including:",
    "+",
    "+- Commit message",
    "+- Diffs",
    "+- Author name and email",
    "+- Committer name and email",
    "+- Timestamps",
    "+- GPG signature",
    "+",
    "+On its own, git log does not output its information in a format which is easy for other programs to use.",
    "+So, this tool parses the output and turns it into JSON which is more easy to analyze and check.",
    "+",
    "+## Usage",
    "+",
    "+Using it is simple, just run the `git log` command and pipe it to the standard input of `git_log_raw_parser`",
    "+",
    "+```",
    "+git log -p --format=raw --show-signature --stat | python3 git_log_raw_parser.py --output-dir=./out/",
    "+```",
    "+",
    "+Or perhaps a bit more realistic:",
    "+",
    "+```",
    "+git clone https://github.com/cfengine/core",
    "+(cd core && git log -p --format=raw --show-signature --stat HEAD~500..HEAD 2>/dev/null) | python3 git_log_raw_parser.py",
    "+```",
    "+",
    "+(Clone CFEngine core, start subshell which enters the subdirectory and runs git log for the past 500 commits).",
    "+",
    "+## Improtant notes",
    "+",
    "+**Warning:** The output of `--show-signature` varies depending on which keys you have imported / trusted in your installation of GPG.",
    "+Make sure you import the correct GPG keys beforehand, and don't expect output to be identical across different machines with different GPG states.",
    "+",
    "+**Warning:** Consider this a best-effort, \"lossy\" parsing.",
    "+Commits may contain non utf-8 characters, to avoid \"crashing\", we skip these, replacing them with question marks.",
    "+Thus, the parsing is lossy, don't expect all the information to be there.",
    "+This tool can be used for searching / analyzing commits, but don't use it as some kind of backup tool where you expect to have the ability to \"reconstruct\" the commits and repo entirely.",
    "+",
    "+## Details",
    "+",
    "+For details on how the parsing works, try running with `--debug` and look at the resulting `./debug/` folder.",
    "+Also, see the comments in the source code; [./git_log_raw_parser.py](./git_log_raw_parser.py)",
    "diff --git a/git_log_raw_parser.py b/git_log_raw_parser.py",
    "new file mode 100644",
    "index 0000000..1be31c7",
    "--- /dev/null",
    "+++ b/git_log_raw_parser.py",
    "@@ -0,0 +1,269 @@",
    "+import os",
    "+import sys",
    "+import argparse",
    "+",
    "+from internal_parser import parse, parse_to_all_representations",
    "+from cfbs.utils import find, mkdir, rm",
    "+from cfbs.pretty import pretty",
    "+",
    "+# Usage:",
    "+# git log -p --format=raw --show-signature --stat | python3 git_log_raw_parser.py",
    "+",
    "+",
    "+class GlobalState:",
    "+    def __init__(self):",
    "+        self.quiet = False",
    "+        self.emails = {}",
    "+        self.names = {}",
    "+        self.fingerprints = {}",
    "+        self.unsigneds = {}",
    "+",
    "+        self.commits = {",
    "+            \"empty\": [],",
    "+            \"unsigned\": [],",
    "+            \"signed-trusted\": [],",
    "+            \"signed-untrusted\": [],",
    "+        }",
    "+",
    "+        self.by_name = {}",
    "+        self.by_email = {}",
    "+        self.by_fingerprint = {}",
    "+        self.by_id = {}",
    "+        self.summary = {}",
    "+        self.trusted = None",
    "+",
    "+        self.set_trusted_fingerprints()",
    "+",
    "+    def _get_trusted_fingerprints(self):",
    "+        for file in find(\"trusted\", extension=\".fp\"):",
    "+            with open(file, \"r\") as f:",
    "+                for line in f:",
    "+                    line = line.strip()",
    "+                    line = line.replace(\" \", \"\")",
    "+                    if line:",
    "+                        yield line",
    "+",
    "+    def set_trusted_fingerprints(self):",
    "+        self.trusted = list(self._get_trusted_fingerprints())",
    "+",
    "+    def record_email(self, email):",
    "+        if email not in self.emails:",
    "+            self.emails[email] = 1",
    "+            print(\"New email: \" + email)",
    "+        else:",
    "+            self.emails[email] += 1",
    "+",
    "+    def record_name(self, name):",
    "+        if name not in self.names:",
    "+            self.names[name] = 1",
    "+            print(\"New name: \" + name)",
    "+        else:",
    "+            self.names[name] += 1",
    "+",
    "+    def record_fingerprint(self, fingerprint):",
    "+        if fingerprint not in self.fingerprints:",
    "+            self.fingerprints[fingerprint] = 1",
    "+            print(\"New fingerprint: \" + fingerprint)",
    "+        else:",
    "+            self.fingerprints[fingerprint] += 1",
    "+",
    "+    def record_unsigned(self, unsigned):",
    "+        if unsigned not in self.unsigneds:",
    "+            self.unsigneds[unsigned] = 1",
    "+            print(\"New unsigned: \" + unsigned)",
    "+        else:",
    "+            self.unsigneds[unsigned] += 1",
    "+",
    "+    def record_user(self, user):",
    "+        name = user[\"name\"]",
    "+        email = user[\"email\"]",
    "+        id = user[\"id\"]",
    "+",
    "+        if name not in self.by_name:",
    "+            self.by_name[name] = {\"emails\": [], \"fingerprints\": []}",
    "+        if email not in self.by_email:",
    "+            self.by_email[email] = {\"names\": [], \"fingerprints\": []}",
    "+        if id not in self.by_id:",
    "+            self.by_id[id] = {\"fingerprints\": []}",
    "+",
    "+        if email not in self.by_name[name][\"emails\"]:",
    "+            self.by_name[name][\"emails\"].append(email)",
    "+",
    "+        if name not in self.by_email[email][\"names\"]:",
    "+            self.by_email[email][\"names\"].append(name)",
    "+",
    "+    def record_by(self, commit):",
    "+        self.record_user(commit[\"author\"])",
    "+        self.record_user(commit[\"committer\"])",
    "+        id = commit[\"committer\"][\"id\"]",
    "+        fingerprint = commit.get(\"fingerprint\", \"unsigned\")",
    "+        if fingerprint != \"unsigned\":",
    "+            if fingerprint not in self.by_fingerprint:",
    "+                self.by_fingerprint[fingerprint] = {\"ids\": []}",
    "+            if id not in self.by_fingerprint[fingerprint][\"ids\"]:",
    "+                self.by_fingerprint[fingerprint][\"ids\"].append(id)",
    "+                if fingerprint not in self.by_id[id][\"fingerprints\"]:",
    "+                    self.by_id[id][\"fingerprints\"].append(fingerprint)",
    "+",
    "+",
    "+global_state = GlobalState()",
    "+",
    "+",
    "+def output_to_directory(output_dir):",
    "+    assert output_dir is not None and output_dir != \"\"",
    "+    if not output_dir.endswith(\"/\"):",
    "+        output_dir = output_dir + \"/\"",
    "+    if (",
    "+        not output_dir.startswith(\"./\")",
    "+        and not output_dir.startswith(\"/\")",
    "+        and not output_dir.startswith(\"~/\")",
    "+    ):",
    "+        output_dir = \"./\" + output_dir",
    "+",
    "+    assert output_dir != \"/\"",
    "+    assert output_dir != \"./\"",
    "+    assert output_dir != \"~/\"",
    "+    assert output_dir != \".\"",
    "+",
    "+    assert os.path.isdir(output_dir) or not os.path.exists(output_dir)",
    "+",
    "+    rm(output_dir, missing_ok=True)",
    "+",
    "+    mkdir(\"./out/\", exist_ok=True)",
    "+",
    "+    with open(\"./out/summary.json\", \"w\") as f:",
    "+        f.write(pretty(global_state.summary) + \"\\n\")",
    "+",
    "+    for key, values in global_state.commits.items():",
    "+        folder = \"./out/\" + key",
    "+        mkdir(folder)",
    "+        with open(folder + \".txt\", \"w\") as links:",
    "+            for commit in values:",
    "+                sha = commit[\"sha\"]",
    "+                links.write(",
    "+                    \"https://github.com/cfengine/masterfiles/commit/\" + sha + \"\\n\"",
    "+                )",
    "+                filename = folder + \"/\" + sha + \".json\"",
    "+                with open(filename, \"w\") as f:",
    "+                    f.write(pretty(commit))",
    "+",
    "+",
    "+def parse_logs(output_dir=None, quiet=False, debug_parser=False):",
    "+    if debug_parser:",
    "+        rm(\"./debug/\")",
    "+        mkdir(\"./debug/\")",
    "+        for raw_commit, split_commit, pretty_commit in parse_to_all_representations(",
    "+            sys.stdin",
    "+        ):",
    "+            sha = pretty_commit[\"sha\"]",
    "+            with open(f\"./debug/{sha}.1.raw.txt\", \"w\") as f:",
    "+                f.write(\"\\n\".join(raw_commit))",
    "+            with open(f\"./debug/{sha}.2.raw.json\", \"w\") as f:",
    "+                f.write(pretty(raw_commit))",
    "+            with open(f\"./debug/{sha}.3.split.json\", \"w\") as f:",
    "+                f.write(pretty(split_commit))",
    "+            with open(f\"./debug/{sha}.4.pretty.json\", \"w\") as f:",
    "+                f.write(pretty(pretty_commit))",
    "+        return",
    "+",
    "+    for commit in parse(sys.stdin):",
    "+        global_state.record_by(commit)",
    "+        global_state.record_email(commit[\"author\"][\"email\"])",
    "+        if commit[\"author\"][\"email\"] != commit[\"committer\"][\"email\"]:",
    "+            global_state.record_email(commit[\"committer\"][\"email\"])",
    "+",
    "+        global_state.record_name(commit[\"author\"][\"name\"])",
    "+        if commit[\"author\"][\"name\"] != commit[\"committer\"][\"name\"]:",
    "+            global_state.record_name(commit[\"committer\"][\"name\"])",
    "+",
    "+        if \"fingerprint\" in commit:",
    "+            global_state.record_fingerprint(",
    "+                commit[\"committer\"][\"id\"] + \" \" + commit[\"fingerprint\"]",
    "+            )",
    "+        else:",
    "+            global_state.record_unsigned(commit[\"committer\"][\"id\"])",
    "+",
    "+        if \"diff\" not in commit:",
    "+            global_state.commits[\"empty\"].append(commit)",
    "+        elif \"fingerprint\" in commit and commit[\"fingerprint\"] in global_state.trusted:",
    "+            global_state.commits[\"signed-trusted\"].append(commit)",
    "+        elif (",
    "+            \"fingerprint\" in commit",
    "+            and commit[\"fingerprint\"] not in global_state.trusted",
    "+        ):",
    "+            global_state.commits[\"signed-untrusted\"].append(commit)",
    "+        else:",
    "+            global_state.commits[\"unsigned\"].append(commit)",
    "+",
    "+    global_state.by_email = {",
    "+        k: v",
    "+        for k, v in global_state.by_email.items()",
    "+        if len(v[\"names\"]) > 1 or len(v[\"fingerprints\"]) > 1",
    "+    }",
    "+    global_state.by_name = {",
    "+        k: v",
    "+        for k, v in global_state.by_name.items()",
    "+        if len(v[\"emails\"]) > 1 or len(v[\"fingerprints\"]) > 1",
    "+    }",
    "+    global_state.by_id = {",
    "+        k: v for k, v in global_state.by_id.items() if len(v[\"fingerprints\"]) > 1",
    "+    }",
    "+    global_state.by_fingerprint = {",
    "+        k: v for k, v in global_state.by_fingerprint.items() if len(v[\"ids\"]) > 1",
    "+    }",
    "+    global_state.summary = {",
    "+        \"emails\": global_state.emails,",
    "+        \"names\": global_state.names,",
    "+        \"fingerprints\": global_state.fingerprints,",
    "+        \"unsigneds\": global_state.unsigneds,",
    "+        \"commit_counts\": {",
    "+            \"empty\": len(global_state.commits[\"empty\"]),",
    "+            \"signed-trusted\": len(global_state.commits[\"signed-trusted\"]),",
    "+            \"signed-untrusted\": len(global_state.commits[\"signed-untrusted\"]),",
    "+            \"unsigned\": len(global_state.commits[\"unsigned\"]),",
    "+        },",
    "+        \"by_name\": global_state.by_name,",
    "+        \"by_email\": global_state.by_email,",
    "+        \"by_id\": global_state.by_id,",
    "+        \"by_fingerprint\": global_state.by_fingerprint,",
    "+    }",
    "+",
    "+    if not quiet:",
    "+        print(pretty(global_state.summary))",
    "+    if output_dir:",
    "+        output_to_directory(output_dir)",
    "+",
    "+",
    "+def get_args():",
    "+    parser = argparse.ArgumentParser(",
    "+        prog=\"git-log-raw-parser\",",
    "+        description=\"Parses the output of 'git log -p --format=raw --show-signature --stat'\",",
    "+    )",
    "+    parser.add_argument(",
    "+        \"-o\", \"--output-dir\", help=\"Output commits to a folder structure\"",
    "+    )",
    "+    parser.add_argument(",
    "+        \"-q\",",
    "+        \"--quiet\",",
    "+        default=False,",
    "+        action=\"store_true\",",
    "+        help=\"Stop printing JSON commits to standard out\",",
    "+    )",
    "+    parser.add_argument(",
    "+        \"-d\",",
    "+        \"--debug\",",
    "+        default=False,",
    "+        action=\"store_true\",",
    "+        help=\"Store debug information to ./debug/\",",
    "+    )",
    "+    args = parser.parse_args()",
    "+    return args",
    "+",
    "+",
    "+def main():",
    "+    args = get_args()",
    "+    parse_logs(output_dir=args.output_dir, quiet=args.quiet, debug_parser=args.debug)",
    "+",
    "+",
    "+if __name__ == \"__main__\":",
    "+    main()",
    "diff --git a/internal_parser.py b/internal_parser.py",
    "new file mode 100644",
    "index 0000000..179cf63",
    "--- /dev/null",
    "+++ b/internal_parser.py",
    "@@ -0,0 +1,264 @@",
    "+from cfbs.pretty import pretty",
    "+",
    "+\"\"\"",
    "+This file contains the internal / library functions for parsing the output",
    "+of 'git log -p --format=raw --show-signature --stat'",
    "+There is intentionally no main function / CLI here, only testable and importable",
    "+functions to perform the parsing. CLI, and additional tracking, summaries etc.",
    "+are implemented in git_log_raw_parser.py",
    "+",
    "+This is done in 4 steps:",
    "+1. Iterate over the input stream generating lines",
    "+2. Iterate over lines, find where the next commit starts, and generate \"raw commits\" (list of lines within one commit)",
    "+3. Iterate over raw commits, find where each section starts, and generate \"split commits\"",
    "+4. Iterate over the split commits, generating pretty commits.",
    "+",
    "+All of this is implemented using generators / iterators, so you can process and output results",
    "+while later commits are still being printed / processed.",
    "+",
    "+Performance-wise, the 4 step parsing outlined above is not ideal, but it helps a lot",
    "+in making the code simpler to write and read and less error prone.",
    "+In pracitce, performance is good enough, even for hundreds, or thousands commits.",
    "+",
    "+If you want to operate on the more raw data without much translations / prettifying,",
    "+you can skip step 4, or steps 3 and 4.",
    "+",
    "+Note: The output of the git log command we use varies based on gpg (which keys are imported).",
    "+      Don't expect the same output on different machines with different gpg states.",
    "+",
    "+Note: The parsing is lossy, we reconfigure the input stream to replace unicode",
    "+      errors (with question marks), so don't expect the diffs or commit messages to be",
    "+      100% correct for these cases.",
    "+\"\"\"",
    "+",
    "+import sys",
    "+from io import TextIOWrapper",
    "+",
    "+",
    "+def _reconfigure(input_stream):",
    "+    # input_stream / sys.stdin is defined as TextIO in typeshed even though it's actually TextIOWrapper by default",
    "+    # This decision was made because it's common to reassign stdin / stdout / stderr:",
    "+    # https://github.com/python/typeshed/issues/10093",
    "+    # For this parser we need to use reconfigure from TextIOWrapper, so we don't",
    "+    # encounter exceptions for commit messages / diffs with weird characters.",
    "+    # So we need to assume that sys.stdin is actually TextIOWrapper,",
    "+    # the assertion makes this assumption explicit and makes strict typecheckers like Pyright happy.",
    "+    assert isinstance(input_stream, TextIOWrapper)",
    "+    input_stream.reconfigure(errors=\"replace\")",
    "+",
    "+",
    "+# Utilities:",
    "+",
    "+",
    "+def remove_prefix(line, prefix):",
    "+    assert line.startswith(prefix)",
    "+    offset = len(prefix)",
    "+    assert offset > 0",
    "+    return line[offset:]",
    "+",
    "+",
    "+def remove_suffix(line, suffix):",
    "+    assert line.endswith(suffix)",
    "+    offset = len(suffix)",
    "+    assert offset > 0",
    "+    return line[0:-offset]",
    "+",
    "+",
    "+def parse_author(line):",
    "+    author = {}",
    "+    split = line.split(\" \")",
    "+    timezone = split[-1]",
    "+    timestamp = split[-2]",
    "+    suffix = \" \" + \" \".join(split[-2:])",
    "+    full = remove_suffix(line, suffix)",
    "+    author[\"id\"] = full",
    "+    assert full[-1] == \">\"",
    "+    full = full[0:-1]",
    "+    split = full.split(\"<\")",
    "+    assert len(split) == 2",
    "+    author[\"name\"] = split[0].strip()",
    "+    author[\"email\"] = split[1].strip()",
    "+    author[\"timestamp\"] = timestamp",
    "+    author[\"timezone\"] = timezone",
    "+    return author",
    "+",
    "+",
    "+def valid_signature(commit):",
    "+    for line in commit[\"gpg\"]:",
    "+        if line.startswith(\"Good signature from \"):",
    "+            return True",
    "+    return False",
    "+",
    "+",
    "+# The main parsing function to use in most cases:",
    "+",
    "+",
    "+def parse(input_stream=None, replace_errors=True):",
    "+    if input_stream is None:",
    "+        input_stream = sys.stdin",
    "+    if replace_errors:",
    "+        _reconfigure(input_stream)",
    "+    lines = input_stream_to_lines(input_stream)",
    "+    raw_commits = lines_to_raw_commits(lines)",
    "+    split_commits = raw_commits_to_split_commits(raw_commits)",
    "+    pretty_commits = split_commits_to_pretty_commits(split_commits)",
    "+    for pretty_commit in pretty_commits:",
    "+        # TODO: Do we want to do something more here?",
    "+        yield pretty_commit",
    "+",
    "+",
    "+# Another version of parse() which gives you all 3 representations of a commit",
    "+# Mostly useful for debugging",
    "+def parse_to_all_representations(input_stream=None, replace_errors=True):",
    "+    if input_stream is None:",
    "+        input_stream = sys.stdin",
    "+    if replace_errors:",
    "+        _reconfigure(input_stream)",
    "+    lines = input_stream_to_lines(input_stream)",
    "+    raw_commits = lines_to_raw_commits(lines)",
    "+    for raw_commit in raw_commits:",
    "+        # These function normally operate on iterators which yield many elements",
    "+        # (the entire git log), but we can call them on a n=1 tuple as well:",
    "+        split_commit = next(raw_commits_to_split_commits((raw_commit,)))",
    "+        pretty_commit = next(split_commits_to_pretty_commits((split_commit,)))",
    "+        yield (raw_commit, split_commit, pretty_commit)",
    "+",
    "+",
    "+# The individual steps / iterators:",
    "+",
    "+",
    "+def input_stream_to_lines(input_stream):",
    "+    for line in input_stream:",
    "+        yield line",
    "+",
    "+",
    "+def lines_to_raw_commits(line_iterator):",
    "+    current_commit = []",
    "+    for line in line_iterator:",
    "+        assert line[-1] == \"\\n\"",
    "+        line = line[0:-1]",
    "+        if line.startswith(\"commit \"):",
    "+            # New commit, finalize previous",
    "+            if current_commit:",
    "+                yield current_commit",
    "+                current_commit = []",
    "+        current_commit.append(line)",
    "+    if current_commit:",
    "+        yield current_commit",
    "+",
    "+",
    "+def raw_commits_to_split_commits(raw_commits):",
    "+    for raw in raw_commits:",
    "+        commit = {}",
    "+        first_line = raw[0]",
    "+        assert len(first_line) == len(\"commit 680e160eef58249b1b896512d50f6342ad325f01\")",
    "+        assert first_line.startswith(\"commit \")",
    "+        commit[\"sha\"] = remove_prefix(first_line, \"commit \")",
    "+        lines = (l for l in raw[1:])",
    "+        line = next(lines)",
    "+        while line and line.startswith(\"gpg: \"):",
    "+            line = remove_prefix(line, \"gpg: \")",
    "+            if \"gpg\" not in commit:",
    "+                commit[\"gpg\"] = []",
    "+            commit[\"gpg\"].append(line)",
    "+            line = next(lines)",
    "+",
    "+        if line and line.startswith(\"Primary key fingerprint: \"):",
    "+            commit[\"Primary key fingerprint\"] = remove_prefix(",
    "+                line, \"Primary key fingerprint: \"",
    "+            )",
    "+            line = next(lines)",
    "+",
    "+        if line and line.startswith(\"     Subkey fingerprint: \"):",
    "+            commit[\"Subkey fingerprint\"] = remove_prefix(",
    "+                line, \"     Subkey fingerprint: \"",
    "+            )",
    "+            line = next(lines)",
    "+",
    "+        print(pretty(raw))",
    "+        assert line and line.startswith(\"tree \")  # TODO: Always?",
    "+        if line and line.startswith(\"tree \"):",
    "+            commit[\"tree\"] = remove_prefix(line, \"tree \")",
    "+            line = next(lines)",
    "+",
    "+        while line and line.startswith(\"parent \"):",
    "+            if not \"parent\" in commit:",
    "+                commit[\"parent\"] = []",
    "+            commit[\"parent\"].append(remove_prefix(line, \"parent \"))",
    "+            line = next(lines)",
    "+        if \"parent\" in commit:",
    "+            assert 0 < len(commit[\"parent\"]) <= 2",
    "+",
    "+        assert line and line.startswith(\"author \")  # TODO: Always?",
    "+        if line and line.startswith(\"author \"):",
    "+            commit[\"author\"] = remove_prefix(line, \"author \")",
    "+            line = next(lines)",
    "+",
    "+        assert line and line.startswith(\"committer \")  # TODO: Always?",
    "+        if line and line.startswith(\"committer \"):",
    "+            commit[\"committer\"] = remove_prefix(line, \"committer \")",
    "+            line = next(lines)",
    "+",
    "+        if line and line.startswith(\"gpgsig \"):",
    "+            commit[\"gpgsig\"] = [remove_prefix(line, \"gpgsig \")]",
    "+            line = next(lines)",
    "+            while not line.startswith(\" -----END PGP SIGNATURE-----\"):",
    "+                assert \"BEGIN PGP SIGNATURE\" not in line",
    "+                commit[\"gpgsig\"].append(line)",
    "+                line = next(lines)",
    "+            assert line == \" -----END PGP SIGNATURE-----\"",
    "+            commit[\"gpgsig\"].append(line)",
    "+            line = next(lines)",
    "+        try:",
    "+            while line == \" \":",
    "+                line = next(lines)",
    "+            while line == \"\":",
    "+                line = next(lines)",
    "+            commit[\"message\"] = []",
    "+            while line and line != \"---\":",
    "+                commit[\"message\"].append(line)",
    "+                line = next(lines)",
    "+            if line and line == \"---\":",
    "+                commit[\"diff\"] = []",
    "+                line = next(lines)",
    "+                for line in lines:",
    "+                    commit[\"diff\"].append(line)",
    "+        except StopIteration:",
    "+            pass",
    "+        yield commit",
    "+",
    "+",
    "+def split_commits_to_pretty_commits(split_commits):",
    "+    for commit in split_commits:",
    "+        final = {}",
    "+        for key, value in commit.items():",
    "+            final[key] = value",
    "+        if \"gpgsig\" in final:",
    "+            assert final[\"gpgsig\"][0] == \"-----BEGIN PGP SIGNATURE-----\"",
    "+            signature = [\"-----BEGIN PGP SIGNATURE-----\"]",
    "+            for line in final[\"gpgsig\"][1:]:",
    "+                assert line.startswith(\" \")",
    "+                signature.append(line[1:])",
    "+            final[\"gpgsig\"] = \"\\n\".join(signature)",
    "+",
    "+        assert \"author\" in final",
    "+        final[\"author\"] = parse_author(final[\"author\"])",
    "+        assert \"committer\" in final",
    "+        final[\"committer\"] = parse_author(final[\"committer\"])",
    "+",
    "+        if \"Primary key fingerprint\" in final:",
    "+            del final[\"Primary key fingerprint\"]",
    "+",
    "+        if \"gpg\" in commit:",
    "+            assert commit[\"gpg\"][0].startswith(\"Signature made \")",
    "+            if not valid_signature(commit):",
    "+                print(\"Bad signature:\" + pretty(commit))",
    "+            final[\"fingerprint\"] = remove_prefix(",
    "+                commit[\"gpg\"][1], \"               using RSA key \"",
    "+            )",
    "+            if \"Primary key fingerprint\" in final:",
    "+                del final[\"Primary key fingerprint\"]",
    "+",
    "+        assert \"message\" in final",
    "+        final[\"message\"] = \"\\n\".join(x[4:] for x in final[\"message\"])",
    "+        yield final",
    "diff --git a/look_for_pulls.py b/look_for_pulls.py",
    "new file mode 100644",
    "index 0000000..9cc9e1f",
    "--- /dev/null",
    "+++ b/look_for_pulls.py",
    "@@ -0,0 +1,23 @@",
    "+import sys",
    "+import os",
    "+",
    "+import requests",
    "+",
    "+pat = os.getenv(\"GH_PAT\")",
    "+",
    "+for line in sys.stdin:",
    "+    headers = {",
    "+        \"Accept\": \"application/vnd.github+json\",",
    "+        \"Authorization\": f\"Bearer {pat}\",",
    "+        \"X-GitHub-Api-Version\": \"2022-11-28\",",
    "+    }",
    "+    line = line.replace(\"github.com\", \"api.github.com/repos\").replace(\"/commit/\", \"/commits/\").strip() + \"/pulls\"",
    "+    r = requests.get(line, headers=headers)",
    "+    if r.status_code != 200:",
    "+        print(\"Bad status code: \" + str(r.status_code) + \" \" + line)",
    "+    data = r.json()",
    "+    if len(data) == 0:",
    "+        print(\"Empty: \" + line)",
    "+        continue",
    "+    target = data[0][\"url\"]",
    "+    print(line + \" -> \" + target)",
    "diff --git a/requirements.txt b/requirements.txt",
    "new file mode 100644",
    "index 0000000..30b6f90",
    "--- /dev/null",
    "+++ b/requirements.txt",
    "@@ -0,0 +1,3 @@",
    "+cf-remote==0.6.4",
    "+cfbs==4.4.0",
    "+requests==2.31.0"
  ],
  "valid_signature": true,
  "fingerprint": "AFE8C5F43057C0093122299F584211AF6AB3EE12"
}
